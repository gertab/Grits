// Examples from the paper 'Back to Futures'

type bin = +{b0 : bin, b1 : bin, e : 1}

let succ(y : bin) : bin = 
    case y (
          b0<y1> => x1 : bin <- new (fwd x1 y1);
                    self.b1<x1>
        | b1<y1> => x1 : bin <- new succ(y1);
                    self.b0<x1>
        | e<y1> =>  x2 : 1 <- new (fwd x2 y1);
                    x1 : bin <- new (x1.e<x2>);
                    self.b1<x1>
    )

let consumeBin(b : bin) : 1 = 
        case b ( b0<c> => print b0; consumeBin(c)
               | b1<c> => print b1; consumeBin(c)
               | e<c>  => print e; wait c; close self)

let printBin(b : bin) : 1 = 
          y <- new consumeBin(b); 
          wait y;
          close self

let test() : bin =
    n11 : 1 <- new close self;
    n12 : bin <- new self.e<n11>;
    n13 : bin <- new self.b1<n12>;
    n14 : bin <- new self.b1<n13>;           
    n1 : bin <- new self.b0<n14>;           
    // n1 = e b1 b1 b0 = 6 

    succ(n1)


// prc[a] : bin = test()
// prc[b] : 1 = printBin(a)

let plus2(z : bin) : bin = 
    y <- new succ(z);
    succ(y)

let test2() : bin =
    n11 : 1 <- new close self;
    n12 : bin <- new self.e<n11>;
    n13 : bin <- new self.b1<n12>;
    n14 : bin <- new self.b1<n13>;
    n1 : bin <- new self.b0<n14>;
    // n1 = e b1 b1 b0 = 6 

    plus2(n1)

// prc[a] : bin = test2()
// prc[b] : 1 = printBin(a)
