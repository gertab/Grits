type bin = linear +{b0 : bin, b1 : bin, e : 1}
type treeBin = linear +{node : treeBin * treeBin, leaf : bin}


 // b1 e = 1
let bin1() : bin =   
  n12 : linear 1 <- new close self;
  n11 : bin <- new self.e<n12>;
  n1 : bin <- new self.b1<n11> ;  
  fwd self n1

let bin4() : bin =
  n23 : linear 1 <- new close self;
  n22 : bin <- new self.e<n23>;
  n21 : bin <- new self.b1<n22>;
  n20 : bin <- new self.b0<n21>;   
  n2 : bin <- new self.b0<n20>; 
  fwd self n2

let bin9() : bin =
  n1 : linear 1 <- new close self;
  n2 : bin <- new self.e<n1>;
  n3 : bin <- new self.b1<n2>;
  n4 : bin <- new self.b0<n3>;
  n5 : bin <- new self.b0<n4>;
  n6 : bin <- new self.b1<n5>;             // b1 b0 b0 b1 e = 1001
  fwd self n6


type nat = linear +{zero : 1, succ : nat}
type uNat = unrestricted +{zero : 1, succ : uNat}

let binToNat(x : bin) : nat = 
    z : lin 1 <- new close self;
    ac : nat <- new self.zero<z>;

    curr'' : unr 1 <- new close self;
    curr' : uNat <- new self.zero<curr''>;
    curr : uNat <- new self.succ<curr'>;
    natProducer : natCounter <- new natProducer(curr);

    binToNatInternal(x, ac, natProducer)

let binToNatInternal(x : bin, ac : nat, natProducer : natCounter) : nat = 
    case x (
          b0<x'> => natProducer' : natCounter <- new natProducer.zero<natProducer'>;
                    binToNatInternal(x', ac, natProducer')
        | b1<x'> => natProducer' : nat * natCounter <- new natProducer.one<natProducer'>;
                    <binaryValue, natProducer''> <- recv natProducer';
                    newAc <- new addNats(binaryValue, ac);
                    binToNatInternal(x', newAc, natProducer'')
        | e<x'>  => wait x';  
                    natProducer' : linear 1 <- new natProducer.terminate<natProducer'>;
                    wait natProducer'; 
                    fwd self ac
    )

type natCounter = linear &{terminate : 1, one : nat * natCounter, zero : natCounter}
let natProducer(curr : uNat) : natCounter = 
    case self (
        terminate<x> => drop curr;
                        close self
        | one<x>     => <curr1, curr2> <- split curr;
                        curr1' <- new double(curr1);
                        curr2' : nat <- new uNatToLinear(curr2);
                        cont <- new natProducer(curr1');
                        send self<curr2', cont>
        | zero<x>    => curr'' <- new double(curr);
                        natProducer(curr'')
    )


let uNatToLinear(x : uNat) : nat = 
    case x (
          zero<x'> => wait x';
                      cls : lin 1 <- new close self;
                      self.zero<cls>
        | succ<x'> => d <- new uNatToLinear(x');
                      self.succ<d>
    )


let double(x : uNat) : uNat =
    case x (
          zero<x'> => self.zero<x'>
        | succ<x'> => h <- new double(x');
                      d : uNat <- new d.succ<h>;
                      self.succ<d>
    )


    

prc[a] : bin = bin4()
prc[b] : nat = binToNat(a)
prc[c] : 1   = printNat(b)


// 5 : S(S(S(S(S(0)))))
let nat5() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  s2 : nat <- new s2.succ<s1>; 
  s3 : nat <- new s3.succ<s2>; 
  s4 : nat <- new s4.succ<s3>; 
  s5 : nat <- new s5.succ<s4>; 
  fwd self s5

// 2 : S(S(0))
let nat2() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  s2 : nat <- new s2.succ<s1>; 
  fwd self s2
  
// Adds two natural numbers
let addNats(x : nat, y : nat) : nat =
    case x (
          zero<x'> => // print zeeeeee;
                      wait x'; fwd self y
        | succ<x'> => // print sccccc;
                      y'' : nat <- new y''.succ<y>;
                      addNats(x', y'')
    )

let consumeNat(n : nat) : 1 = 
        case n ( zero<c> => print zero; wait c; close self
               | succ<c> => print succ; consumeNat(c))

let printNat(n : nat) : 1 = 
          y <- new consumeNat(n); 
          wait y;
          close self

//prc[a] : nat = nat5()
//prc[b] : nat = nat2()
//prc[c] : nat = addNats(a, b)
//prc[d] : 1   = printNat(c)


let printBin(b : bin) : 1 = 
        case b ( b0<c> => print b0; printBin(c)
               | b1<c> => print b1; printBin(c)
               | e<c>  => print e; wait c; close self)

//prc[a] : bin = bin2()
//prc[b] : 1   = printBin(a)