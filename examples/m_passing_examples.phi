// Examples from 'A Message-Passing Interpretation of Adjoint Logic'

// Run using:
// go run . --verbosity 2 examples/m_passing_examples.phi

// Example 1
type A = mul 1 * 1
type B = mul 1
let eg1(x : A * B) : B * A  = 
    <y, x'> <- recv x; 
    send self<x', y>

// Example 2
type A2 = lin 1
type B2 = lin 1
type lr = +{left : A2, right : B2}
type lr' = &{left : A2, right : B2}

let eg2(x : lr, y : lr') : A2 * B2  = 
    case x (
        left<x'>  => y' : B2 <- new y.right<self>;
                     send self<x', y'>
      | right<x'> => y' : A2 <- new y.left<self>;
                     send self<y', x'>
    )

// Example 3
type A3 = 1
type B3 = 1

type C3 = &{left : A3, right : B3}

let eg3(p : C3) : A3 * B3 = 
    q : C3 <- new fwd self p;
    <p1, p2> <- split q;
    x : A3 <- new p1.left<self>;
    y : B3 <- new p2.right<self>;
    send self<x, y>

// Example 4
type A4 = aff 1
type B4 = aff 1

let eg4(x : aff A4 * B4) : aff &{left : A4, right : B4} =
    case self (
        left<p1>  => <y, z> <- recv x; 
                     drop z;
                     fwd p1 y
      | right<p2> => <y, z> <- recv x; 
                     drop y;
                     fwd p2 z
    )

// Run using:
// go run . -verbosity 2 examples/m_passing_examples.phi

// prc[b] : aff &{left : A4, right : B4} = eg4(x)
// prc[x] : aff A4 * B4 = send self<g, h>
// prc[g] : aff A4 = close self
// prc[h] : aff B4 = close self
// prc[otherSide] : A4 = b.left<self> //  /* consume a */

// Example 5
// Taking mode k as linear, and m as affine

// type A5 = aff 1
// type B5 = aff 1
// 
// let eg5(f : aff \/ lin (A5 -* B5)) : (aff \/ lin A5) -* (aff \/ lin B5) = 
//     <x, y> <- recv self;
//     w <- shift f;
//     v <- shift x;
//     z : aff \/ lin B5 <- new cast y<self>; /*problem due to y referring to old self*/
//     send w<v, z>
type A5 = aff 1
type B5 = aff 1 * 1

let eg5(f : aff \/ lin (A5 -* B5)) : (aff \/ lin A5) -* (aff \/ lin B5) = 
    <x, y> <- recv self;
    w <- shift f;
    v <- shift x;
    z : B5 <- new send w<v, self>; /*fixed problem by changing order*/
    cast y<z>

// Example 6 (reverse direction)

type A6 = 1
type B6 = 1
type C6 = 1

type yType = &{left : A6 -* C6, right : B6 -* C6}
type resType = +{left : A6, right : B6} -* C6
let eg6(y : yType) : resType = 
    <ab, c> <- recv self;
    case ab (
          left<a>  => ac : A6 -* C6 <- new y.left<self>;
                      send ac<a, c>
        | right<b> => bc : B6 -* C6 <- new y.right<self>;
                      send bc<b, c>
    )


// Example 9 (Circuits)
// type bits = +{b0 : bits, b1 : bits}
// let nor(x : bits, y : bits) : bits = 
//     case x (
//           b0<x'> => case y (
//                           b0<y'> => z' : bits <- new (self.b1<z'>); // problem with multiple selfs (inc z')
//                                     nor(z', x', y')
//                         | b1<y'> => z' : bits <- new (self.b0<z'>); // same
//                                     nor(z', x', y')
//                     ) 
//         | b1<x'> => case y (
//                           b0<y'> => z' : bits <- new (self.b0<z'>); // same
//                                     nor(z', x', y')
//                         | b1<y'> => z' : bits <- new (self.b0<z'>); // same
//                                     nor(z', x', y')
//                     ) 
//     )
// Example 9 (Circuits - slightly modified)
type bits = +{b0 : bits, b1 : bits}
let nor(x : bits, y : bits) : bits = 
    case x (
          b0<x'> => case y (
                          b0<y'> => z' <- new nor(x', y');
                                    self.b1<z'> // problem with multiple selfs (inc z')
                                    
                        | b1<y'> => z' <- new nor(x', y');
                                    self.b0<z'>
                    ) 
        | b1<x'> => case y (
                          b0<y'> => z' <- new nor(x', y');
                                    self.b0<z'>
                        | b1<y'> => z' <- new nor(x', y');
                                    self.b0<z'>
                    ) 
    )

let or(x : bits, y : bits) : bits = 
    w <- new nor(x, y);
    <u, u'> <- split w;
    nor(u, u')

// Example 10
// Refer to nat_list_map.phi
