
// Examples from the sax language

type bin = +{b0 : bin, b1 : bin, e : 1}
type list = +{cons : bin * list, nil : 1}

let append(L : list, K : list) : list =
  case L ( cons<c> => 
                <x, L2> <- recv c;
                R <- new append(L2, K);
                zz : bin * list <- new (send self<x, R>);
                self.cons<zz>
         | nil<c> => wait c; 
                     fwd self K)

let append2(L : list, K : list) : list =
  case L ( cons<p> => 
                <x, L2> <- recv p;
                R2 <- new append2(L2, K);
                p2 : bin * list <- new send p2<x, R2>;
                self.cons<p2>  
         | nil<u> => 
                wait u; 
                fwd self K)

let rev(l : list, accum : list) : list =
  case l ( cons<p> =>      
                <x, l'> <- recv p;
                t : bin * list <- new send t<x, accum>;
                accum2 : list <- new accum2.cons<t>;
                rev(l', accum2)
         | nil<u> => 
                wait u;
                fwd self accum
  )

let reverse(l : list) : list =
  a : list <- new nilList();
  rev(l, a)

// Nil list
let nilList() : list = 
  c : 1 <- new close self;
  self.nil<c>

let append123() : list =
  n12 : 1 <- new close self;
  n11 : bin <- new self.e<n12>;
  n1 : bin <- new self.b1<n11> ;   // n1: 'b1 'e

  n23 : 1 <- new close self;
  n22 : bin <- new self.e<n23>;
  n21 : bin <- new self.b1<n22>;
  n2 : bin <- new self.b0<n21>;             // n2: 'b0 'b1 'e

  lnil11 <- new nilList();
  l11 : bin * list <- new send self<n1, lnil11>;
  l1 : list <- new self.cons<l11>;          // l1 : cons(n1, nil)    
 
  lnil21 <- new nilList();
  l21 : bin * list <- new send self<n2, lnil21>;
  l2 : list <- new self.cons<l21>;          // l2 : cons(n2, nil)
  
  x <- new append(l1, l2);        // result : cons(n1, cons(n2, nil))
  fwd self x
 
let getBin() : bin =
  n13 : 1 <- new close self;
  n12 : bin <- new self.e<n13>;
  n11 : bin <- new self.b1<n12>;
  n1 : bin <- new self.b0<n11>;            // 'b0 'b1 'e
  fwd self n1

let getOtherBin() : bin =
  n13 : 1 <- new close self;
  n11 : bin <- new self.e<n13>;
  n1 : bin <- new self.b1<n11>;            // 'b1 'e
  fwd self n1

let getList() : list =
  n1 <- new getOtherBin();
  n2 <- new getBin();
  lnil <- new nilList();
  lres21 : bin * list <- new send self<n2, lnil>;
  lres2 : list <- new self.cons<lres21>;            // lres2 : cons(n2, nil)
  lres1 : bin * list <- new send self<n1, lres2>;
  lres : list <- new self.cons<lres1>;              // lres : cons(n1, cons(n2, nil))
  fwd self lres


// cons(n1, nil)
let getListN1() : list =
  n1 <- new getOtherBin();
  lnil <- new nilList();
  lres1 : bin * list <- new send self<n1, lnil>;
  self.cons<lres1>

// cons(n2, nil)
let getListN2() : list =
  n2 <- new getBin();
  lnil <- new nilList();
  lres21 : bin * list <- new send self<n2, lnil>;
  self.cons<lres21> 

let appendN1N2() : list =
    n1 <- new getListN1();          // cons('b1 'e, nil)
    n2 <- new getListN2();          // cons('b0 'b1 'e, nil)
    nappend <- new append2(n1, n2);
    fwd self nappend


let consumeBin(b : bin) : 1 = 
        case b ( b0<c> => print b0; consumeBin(c)
               | b1<c> => print b1; consumeBin(c)
               | e<c>  => print e; wait c; close self)

let consumeList(l : list) : 1 = 
        case l ( cons<c> => print cons;
                            <b, L2> <- recv c;
                            bConsume <- new consumeBin(b);
                            wait bConsume;
                            consumeList(L2)
               | nil<c>  => print nil;
                            wait c;
                            close self)

let printList(l : list) : 1 = 
          y <- new consumeList(l); 
          wait y;
          close self

// prc[a] : list = append123()
// prc[b] : 1 = printList(a)

// prc[c] : list = append123()
// prc[c_rev] : list = reverse(c)
// prc[d] : 1 = printList(c_rev)


// prc[a] : bin = getBin()
// prc[b] : 1 = consumeBin(a) // consume result

// prc[a] : list = appendN1N2()
// prc[b] : 1 = consumeList(a) // consume result


type nat = +{zero : 1, succ : nat}

let half(x : nat) : nat =
  case x (
      zero<x'> => self.zero<x'>
    | succ<x'> => 
            case x' (
                zero<x''> => self.zero<x''>
              | succ<x''> => h <- new half(h, x'');
                             self.succ<h>
            )
  )

// 5 : S(S(S(S(S(0)))))
let nat5() : nat =
  t : 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  s2 : nat <- new s2.succ<s1>; 
  s3 : nat <- new s3.succ<s2>; 
  s4 : nat <- new s4.succ<s3>; 
  s5 : nat <- new s5.succ<s4>; 
  fwd self s5

let consumeNat(n : nat) : 1 = 
        case n ( zero<c> => print zero; wait c; close self
               | succ<c> => print succ; consumeNat(c))

let printNat(n : nat) : 1 = 
          y <- new consumeNat(n); 
          wait y;
          close self



// prc[a] : nat = nat5()
// prc[b] : 1 = printNat(a)

// prc[a] : nat = nat5()
// prc[b] : nat = half(a)
// prc[c] : 1 = printNat(b)


// 10 : S(S(S(S(S(S(S(S(S(S(0))))))))))
let nat10() : nat =
  t   : 1   <- new close t;
  z   : nat <- new z.zero<t>;
  s1  : nat <- new s1.succ<z>; 
  s2  : nat <- new s2.succ<s1>; 
  s3  : nat <- new s3.succ<s2>; 
  s4  : nat <- new s4.succ<s3>; 
  s5  : nat <- new s5.succ<s4>;
  s6  : nat <- new s6.succ<s5>;
  s7  : nat <- new s7.succ<s6>;
  s8  : nat <- new s8.succ<s7>;
  s9  : nat <- new s9.succ<s8>;
  s10 : nat <- new s10.succ<s9>;
  fwd self s10

prc[a] : nat = nat10()
prc[b] : nat = half(a)
prc[c] : 1 = printNat(b)

