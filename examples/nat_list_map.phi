// 'Map' adapted from Example 10 of 'A Message-Passing Interpretation of Adjoint Logic' 

// Natural number types, and a list of natural numbers
type nat = linear +{zero : 1, succ : nat}
type listNat = linear +{cons : nat * listNat, nil : 1}

type mapType = linear /\ replicable (nat -* nat)

// Takes a list of natural numbers and performs a mapping function 
// 'f' (replicable mode) on each element, providing an updated list
let map(f : mapType, l : listNat) : listNat =
    case l (
          cons<l'> => <curr, l''> <- recv l';
                      <f', f''> <- split f;                           // replicate the mapping function f
                      fl : lin (nat -* nat) <- new cast f'<self>;     // obtain linear version of f'
                      curr_updated : nat <- new send fl<curr, self>;  // map current element
                      k'' : listNat <- new map(f'', l'');             // map the remaining elements
                      k' : nat * listNat <- new send self<curr_updated,k''>;
                      self.cons<k'>                                   // provide the result
        | nil<l'>  => drop f;                                         // mapping function 'f' is unused
                      self.nil<l'>
    )

// Replicable process that increments a number
let mapByIncrementing() : mapType  = 
    s <- shift self;           
    <toAdd, result> <- recv s; 
    self.succ<toAdd>              // increment by one 'succ'

// Replicable process that doubles a number
let mapByDoubling() : mapType  = 
    s <- shift self;
    <toDouble, result> <- recv s;
    doubled <- new double(toDouble);
    fwd result doubled

// Initialize each process individually
//prc[l] : listNat = list123()
//prc[f] : mapType =  mapByIncrementing()
////prc[f] : mapType =  mapByDoubling()
//prc[b] : listNat = map(f, l) 
//prc[c] : linear 1 = printListNat(b)

let init() : linear 1 =
    l : listNat <- new list123();
    f : mapType <- new mapByIncrementing();
    b : listNat <- new map(f, l);
    printListNat(b)

// Initialize process running init (these two are equivalent)
//prc[main] : linear 1 = init()
exec init()

// Init without print function
let init2() : listNat =
    l : listNat <- new list123();
    f : mapType <- new mapByIncrementing();
    map(f, l)

///////// Natural Number Operations /////////

// Adds two natural numbers
let addNats(x : nat, y : nat) : nat =
    case x (
          zero<x'> => // print zeeeeee;
                      wait x'; fwd self y
        | succ<x'> => // print sccccc;
                      y'' : nat <- new y''.succ<y>;
                      addNats(x', y'')
    )

// Returns the double value for a natural number
let double(x : nat) : nat =
    case x (
          zero<x'> => self.zero<x'>
        | succ<x'> => h <- new double(x');
                      d : nat <- new d.succ<h>;
                      self.succ<d>
    )


///////// Natural numbers constants /////////

// Create a list containing the numbers 3, 2 and 1: 
//   cons(3, cons(2, cons(1, nil))), 
//   where 1, 2 and 3 are represented as a nat structure
let list123() : listNat =
    n1 : nat <- new nat1(); // succ(zero)
    n2 : nat <- new nat2(); // succ(succ(zero))
    n3 : nat <- new nat3(); // succ(succ(succ(zero)))

    lnil' : linear 1    <- new close self;
    lnil : listNat      <- new self.nil<lnil'>;
    l1' : nat * listNat <- new send self<n1, lnil>;
    l1 : listNat        <- new self.cons<l1'>;    
    l2' : nat * listNat <- new send self<n2, l1>;
    l2 : listNat        <- new self.cons<l2'>;    
    l3' : nat * listNat <- new send self<n3, l2>;
    l3 : listNat        <- new self.cons<l3'>;    
    fwd self l3

// 1 : S(0)
let nat1() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  fwd self s1

// 2 : S(S(0))
let nat2() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  s2 : nat <- new s2.succ<s1>; 
  fwd self s2

// 3 : S(S(S(0)))
let nat3() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  s2 : nat <- new s2.succ<s1>; 
  s3 : nat <- new s3.succ<s2>; 
  fwd self s3

// 4 : S(S(S(S(0))))
let nat4() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  s2 : nat <- new s2.succ<s1>; 
  s3 : nat <- new s3.succ<s2>; 
  s4 : nat <- new s4.succ<s3>; 
  fwd self s4

// 5 : S(S(S(S(S(0)))))
let nat5() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  s2 : nat <- new s2.succ<s1>; 
  s3 : nat <- new s3.succ<s2>; 
  s4 : nat <- new s4.succ<s3>; 
  s5 : nat <- new s5.succ<s4>; 
  fwd self s5

///////// Printing Helpers /////////

let consumeListNat(l : listNat) : lin 1 = 
        case l ( cons<c> => print _cons_;
                            <element, remainingList> <- recv c;
                            elementDone <- new consumeNat(element);
                            wait elementDone;
                            rightDone <- new consumeListNat(remainingList);
                            wait rightDone;
                            close self
               | nil<c> =>  print _nil_;
                            wait c; close self
        )

let printListNat(l : listNat) : lin 1 = 
          y <- new consumeListNat(l); 
          wait y;
          close self

let consumeNat(n : nat) : lin 1 = 
        case n ( zero<c> => print zero; wait c; close self
               | succ<c> => print succ; consumeNat(c))

let printNat(n : nat) : lin 1 = 
          y <- new consumeNat(n); 
          wait y;
          close self

