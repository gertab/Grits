// 'Map' adapted from Example 10 of 'A Message-Passing Interpretation of Adjoint Logic' 

// Natural number types, and a list of natural numbers
type nat = linear +{zero : 1, succ : nat}
type listNat = linear +{cons : nat * listNat, nil : 1}

// Takes a list of natural numbers and performs a mapping function 'f' (replicable mode) on each element, providing an updated list
let map(f : linear /\ replicable (nat -* nat), l : listNat) : listNat =
    case l (
          cons<l'> => <curr, l''> <- recv l';
                      <f', f''> <- split f;                           // replicate the mapping function f
                      fl : lin (nat -* nat) <- new cast f'<self>;     // obtain linear version of f'
                      curr_updated : nat <- new send fl<curr, self>;  // map current element
                      k'' : listNat <- new map(f'', l'');             // map the remaining elements
                      k' : nat * listNat <- new send self<curr_updated,k''>;
                      self.cons<k'>                                   // provide the result
        | nil<l'>  => drop f;                                         // mapping function 'f' is unused
                      self.nil<l'>
    )

// Replicable process that doubles a number
let mapByDoubling() : linear /\ replicable (nat -* nat)  = 
  s <- shift self;
  <toDouble, result> <- recv s;
  doubled <- new double(toDouble);
  fwd result doubled

// Replicable process that increments a number
let mapByIncrementing() : linear /\ replicable (nat -* nat)  = 
  s <- shift self;              //
  <toAdd, result> <- recv s;    // 
  self.succ<toAdd>              // increment by one 'succ'

// Create a list containing the numbers 3, 2 and 1: 
//   cons(3, cons(2, cons(1, nil))), 
//   where 1, 2 and 3 are represented as a nat structure
let list123() : listNat =
  // n1 : 1
  n1 : nat <- new nat1();
  // n2 : 10
  n2 : nat <- new nat2();
  // n3 : 11
  n3 : nat <- new nat3();

  // l1 : cons(n1, nil) 
  lnil' : linear 1    <- new close self;
  lnil : listNat      <- new self.nil<lnil'>;
  l1' : nat * listNat <- new send self<n1, lnil>;
  l1 : listNat        <- new self.cons<l1'>;    
  l2' : nat * listNat <- new send self<n2, l1>;
  l2 : listNat        <- new self.cons<l2'>;    
  l3' : nat * listNat <- new send self<n3, l2>;
  l3 : listNat        <- new self.cons<l3'>;    
  fwd self l3

prc[t] : listNat = list123()
prc[f] : linear /\ replicable (nat -* nat) =  mapByIncrementing()
//prc[f] : linear /\ replicable (nat -* nat) =  mapByDoubling()
prc[b] : listNat = map(f, t) 
prc[c] : linear 1 = printListNat(b)


///////// Natural Number Operations /////////

// Adds two natural numbers
let addNats(x : nat, y : nat) : nat =
    case x (
          zero<x'> => // print zeeeeee;
                      wait x'; fwd self y
        | succ<x'> => // print sccccc;
                      y'' : nat <- new y''.succ<y>;
                      addNats(x', y'')
    )

// Returns the double value for a natural number
let double(x : nat) : nat =
    case x (
          zero<x'> => self.zero<x'>
        | succ<x'> => h <- new double(x');
                      d : nat <- new d.succ<h>;
                      self.succ<d>
    )


///////// Natural numbers constants /////////

// 1 : S(0)
let nat1() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  fwd self s1

// 2 : S(S(0))
let nat2() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  s2 : nat <- new s2.succ<s1>; 
  fwd self s2

// 3 : S(S(S(0)))
let nat3() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  s2 : nat <- new s2.succ<s1>; 
  s3 : nat <- new s3.succ<s2>; 
  fwd self s3

// 4 : S(S(S(S(0))))
let nat4() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  s2 : nat <- new s2.succ<s1>; 
  s3 : nat <- new s3.succ<s2>; 
  s4 : nat <- new s4.succ<s3>; 
  fwd self s4

// 5 : S(S(S(S(S(0)))))
let nat5() : nat =
  t : lin 1 <- new close t;
  z  : nat <- new z.zero<t>;
  s1 : nat <- new s1.succ<z>; 
  s2 : nat <- new s2.succ<s1>; 
  s3 : nat <- new s3.succ<s2>; 
  s4 : nat <- new s4.succ<s3>; 
  s5 : nat <- new s5.succ<s4>; 
  fwd self s5

///////// Printing Helpers /////////

let consumeListNat(l : listNat) : lin 1 = 
        case l ( cons<c> => print _cons_;
                            <element, remainingList> <- recv c;
                            elementDone <- new consumeNat(element);
                            wait elementDone;
                            rightDone <- new consumeListNat(remainingList);
                            wait rightDone;
                            close self
               | nil<c> =>  print _nil_;
                            wait c; close self
        )

let printListNat(l : listNat) : lin 1 = 
          y <- new consumeListNat(l); 
          wait y;
          close self

let consumeNat(n : nat) : lin 1 = 
        case n ( zero<c> => print zero; wait c; close self
               | succ<c> => print succ; consumeNat(c))

let printNat(n : nat) : lin 1 = 
          y <- new consumeNat(n); 
          wait y;
          close self

