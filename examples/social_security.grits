// Construction of a social security number which is used in a hospital when admitting patients

// Types

type digit = rep +{_0 : 1,
                   _1 : 1,
                   _2 : 1,
                   _3 : 1,
                   _4 : 1,
                   _5 : 1,
                   _6 : 1,
                   _7 : 1,
                   _8 : 1,
                   _9 : 1}

type ssn = mul +{cons : (rep \/ mul digit) * ssn, nil : 1}

///////// Start Execution /////////

let main() : lin 1 =
    ss : ssn <- new ssExample(); // contains social security number 012
    <ss1, ss2> <- split ss;

    // Used by insurance agency
    print _insurance_;
    i <- new insurance(ss1);
    wait i;

    // Used by hospital admission
    print _hospital_admission_;
    h <- new hospital_admission(ss2);
    case h (
        found<h'>     => print found_patient; wait h'; close self
      | not_found<h'> => print not_found; wait h'; close self
    )

// Execute main
exec main()

// // Initialize each process individually
// assuming ss : ssn, 
//          h : lin +{found : 1, not_found : 1}
// //prc[ss1, ss2] : ssn = ssExample()
// // prc[h] : lin +{found : 1, not_found : 1} = hospital_admission(ss2)
// prc[i] : lin 1 = insurance(ss)
// prc[p] : lin 1 = wait i;
//                  case h (
//                      found<h'>     => print found_patient; wait h'; close self
//                    | not_found<h'> => print not_found; wait h'; close self
//                  )
// //prc[b] : lin 1 = printSS(a'')

///////// Hospital /////////


let hospital_admission(n : ssn) : lin +{found : 1, not_found : 1} =
    ss_even_odd : mul +{even : 1, odd : 1} <- new even_odd(n);

    case ss_even_odd (
        even<c> =>
            wait c;
            print even;
            c' : lin 1 <- new close self;
            self.found<c'>
      | odd<c> =>
            wait c;
            print odd;
            c' : lin 1 <- new close self;
            self.not_found<c'>
    )

// Check whether the ssn is even or odd
let even_odd(n : ssn) : mul +{even : 1, odd : 1} =
    c : rep 1 <- new close self;
    d : digit <- new self._0<c>; // dummy digit
    even_odd_inner(n, d)

let even_odd_inner(n : ssn, result : digit) : mul +{even : 1, odd : 1} =
    case n (
        cons<n'> => 
            <d, tail> <- recv n';
            d' <- shift d;
            drop result;
            even_odd_inner(tail, d')
      | nil<n'> =>
            wait n';
            even_odd_digit(result)
    )

let even_odd_digit(d : digit) : mul +{even : 1, odd : 1} =
    case d (
        _0<c>  => wait c; 
                    c' : mul 1 <- new close self;
                    self.even<c'>
      | _1<c>   => wait c; 
                    c' : mul 1 <- new close self;
                    self.odd<c'>
      | _2<c>   => wait c; 
                    c' : mul 1 <- new close self;
                    self.even<c'>
      | _3<c> => wait c; 
                    c' : mul 1 <- new close self;
                    self.odd<c'>
      | _4<c>  => wait c; 
                    c' : mul 1 <- new close self;
                    self.even<c'>
      | _5<c>  => wait c; 
                    c' : mul 1 <- new close self;
                    self.odd<c'>
      | _6<c>   => wait c; 
                    c' : mul 1 <- new close self;
                    self.even<c'>
      | _7<c> => wait c; 
                    c' : mul 1 <- new close self;
                    self.odd<c'>
      | _8<c> => wait c; 
                    c' : mul 1 <- new close self;
                    self.even<c'>
      | _9<c>  => wait c; 
                    c' : mul 1 <- new close self;
                    self.odd<c'>
    )

// Ensure that the number is two or more digits long
let length_validation(n : ssn) : mul +{ok : 1, not_ok : 1} =
    case n (
        cons<n'> => 
            // length = 1+
            <d, tail> <- recv n';
            d <- shift d;
            drop d;

            case tail (
                cons<n''> =>
                    // length = 2+
                    <d', tail'> <- recv n'';
                    d' <- shift d';
                    drop d';
                    consume <- new consume_tail(tail');
                    self.ok<consume>
               | nil<n'> => 
                    self.not_ok<n'>
            )
      | nil<n'> => 
            self.not_ok<n'>
    )

let consume_tail(n : ssn) : mul 1 =
    case n ( cons<n'> => <d, tail> <- recv n';
                         d <- shift d;
                         drop d;
                         consume_tail(tail)
           | nil<n'>  => wait n'; close self
    )



///////// Insurance /////////
let insurance(n : ssn) : lin 1 =
    n' <- new encrypt(n);
    print encrypted_ss;
    p <- new printSS(n');
    wait p;
    print end_of_encrypted_ss;
    close self
    
type ss_cons = mul (rep \/ mul digit) * ssn

// encryption by flipping each digit, e.g. 0 -> 9, 1 -> 8, ..., 8 -> 1, 9 -> 0
let encrypt(n : ssn) : ssn =
    case n ( cons<c> => 
        <curr_digit, remaining_number> <- recv c;
        curr_digit' <- shift curr_digit;
        case curr_digit' (
            _0<c> => inverted : digit <- new self._9<c>; 
                     inverted_rep : rep \/ mul digit <- new cast self<inverted>;
                     remaining_inverted : ssn <- new encrypt(remaining_number);
                     remaining : ss_cons <- new send self<inverted_rep, remaining_inverted>;
                     self.cons<remaining>
          | _1<c> => inverted : digit <- new self._8<c>; 
                     inverted_rep : rep \/ mul digit <- new cast self<inverted>;
                     remaining_inverted : ssn <- new encrypt(remaining_number);
                     remaining : ss_cons <- new send self<inverted_rep, remaining_inverted>;
                     self.cons<remaining>
          | _2<c> => inverted : digit <- new self._7<c>; 
                     inverted_rep : rep \/ mul digit <- new cast self<inverted>;
                     remaining_inverted : ssn <- new encrypt(remaining_number);
                     remaining : ss_cons <- new send self<inverted_rep, remaining_inverted>;
                     self.cons<remaining>
          | _3<c> => inverted : digit <- new self._6<c>; 
                     inverted_rep : rep \/ mul digit <- new cast self<inverted>;
                     remaining_inverted : ssn <- new encrypt(remaining_number);
                     remaining : ss_cons <- new send self<inverted_rep, remaining_inverted>;
                     self.cons<remaining>
          | _4<c> => inverted : digit <- new self._5<c>; 
                     inverted_rep : rep \/ mul digit <- new cast self<inverted>;
                     remaining_inverted : ssn <- new encrypt(remaining_number);
                     remaining : ss_cons <- new send self<inverted_rep, remaining_inverted>;
                     self.cons<remaining>
          | _5<c> => inverted : digit <- new self._4<c>; 
                     inverted_rep : rep \/ mul digit <- new cast self<inverted>;
                     remaining_inverted : ssn <- new encrypt(remaining_number);
                     remaining : ss_cons <- new send self<inverted_rep, remaining_inverted>;
                     self.cons<remaining>
          | _6<c> => inverted : digit <- new self._3<c>; 
                     inverted_rep : rep \/ mul digit <- new cast self<inverted>;
                     remaining_inverted : ssn <- new encrypt(remaining_number);
                     remaining : ss_cons <- new send self<inverted_rep, remaining_inverted>;
                     self.cons<remaining>
          | _7<c> => inverted : digit <- new self._2<c>; 
                     inverted_rep : rep \/ mul digit <- new cast self<inverted>;
                     remaining_inverted : ssn <- new encrypt(remaining_number);
                     remaining : ss_cons <- new send self<inverted_rep, remaining_inverted>;
                     self.cons<remaining>
          | _8<c> => inverted : digit <- new self._1<c>; 
                     inverted_rep : rep \/ mul digit <- new cast self<inverted>;
                     remaining_inverted : ssn <- new encrypt(remaining_number);
                     remaining : ss_cons <- new send self<inverted_rep, remaining_inverted>;
                     self.cons<remaining>
          | _9<c> => inverted : digit <- new self._0<c>; 
                     inverted_rep : rep \/ mul digit <- new cast self<inverted>;
                     remaining_inverted : ssn <- new encrypt(remaining_number);
                     remaining : ss_cons <- new send self<inverted_rep, remaining_inverted>;
                     self.cons<remaining>
        )
            
       | nil<c> => self.nil<c>
    )

// decrypt by encrypting again
let decrypt(n : ssn) : ssn =
    encrypt(n)


///////// Social Security Sample /////////

// Social Security example: 012 = cons(0, cons(1, cons(2, nil)))
let ssExample() : ssn =
    // nil
    lnil' : mul 1              <- new close self;
    lnil  : ssn <- new self.nil<lnil'>;
    // 2
    n2 <- new two();
    l2' : (rep \/ mul digit) * ssn <- new send self<n2, lnil>;
    l2  : ssn         <- new self.cons<l2'>;
    // 1
    n1 <- new one();
    l1' : (rep \/ mul digit) * ssn <- new send self<n1, l2>;
    l1  : ssn         <- new self.cons<l1'>;
    // 0
    n0 <- new zero();
    l0' : (rep \/ mul digit) * ssn <- new send self<n0, l1>;
    self.cons<l0'>

// Social Security example: 13 = cons(1, cons(3, nil))
let ssExample2() : ssn =
    // nil
    lnil' : mul 1              <- new close self;
    lnil  : ssn <- new self.nil<lnil'>;
    // 3
    n3 <- new three();
    l3' : (rep \/ mul digit) * ssn <- new send self<n3, lnil>;
    l3  : ssn   <- new self.cons<l3'>;
    // 1
    n1 <- new one();
    l1' : (rep \/ mul digit) * ssn <- new send self<n1, l3>;
    self.cons<l1'>

// 0
let zero() : rep \/ mul digit =
    c : rep 1 <- new close self;
    n : digit <- new self._0<c>;
    cast self<n>

// 1
let one() : rep \/ mul digit =
    c : rep 1 <- new close self;
    n : digit <- new self._1<c>;
    cast self<n>

// 2
let two() : rep \/ mul digit =
    c : rep 1 <- new close self;
    n : digit <- new self._2<c>;
    cast self<n>

// 3
let three() : rep \/ mul digit =
    c : rep 1 <- new close self;
    n : digit <- new self._3<c>;
    cast self<n>

// 4
let four() : rep \/ mul digit =
    c : rep 1 <- new close self;
    n : digit <- new self._4<c>;
    cast self<n>

// 5
let five() : rep \/ mul digit =
    c : rep 1 <- new close self;
    n : digit <- new self._5<c>;
    cast self<n>

// 6
let six() : rep \/ mul digit =
    c : rep 1 <- new close self;
    n : digit <- new self._6<c>;
    cast self<n>

// 7
let seven() : rep \/ mul digit =
    c : rep 1 <- new close self;
    n : digit <- new self._7<c>;
    cast self<n>

// 8
let eight() : rep \/ mul digit =
    c : rep 1 <- new close self;
    n : digit <- new self._8<c>;
    cast self<n>

// 9
let nine() : rep \/ mul digit =
    c : rep 1 <- new close self;
    n : digit <- new self._9<c>;
    cast self<n>


///////// Printing Helpers /////////

let printSS(l : ssn) : lin 1 = 
          y <- new consumeSocialSecurityNo(l); 
          wait y;
          close self

let consumeSocialSecurityNo(l : ssn) : mul 1 = 
        case l ( cons<c> => // print _cons_;
                            <element, remainingList> <- recv c;
                            elementDone <- new consumeDigit(element);
                            wait elementDone;
                            rightDone <- new consumeSocialSecurityNo(remainingList);
                            wait rightDone;
                            close self
               | nil<c> =>  //print _nil_;
                            wait c; close self
        )

let consumeDigit(n : rep \/ mul digit) : mul 1 = 
    n <- shift n;
    case n (  _0<c>  => print '0; wait c; close self
            | _1<c>   => print _1; wait c; close self
            | _2<c>   => print _2; wait c; close self
            | _3<c> => print _3; wait c; close self
            | _4<c>  => print _4; wait c; close self
            | _5<c>  => print _5; wait c; close self
            | _6<c>   => print _6; wait c; close self
            | _7<c> => print _7; wait c; close self
            | _8<c> => print _8; wait c; close self
            | _9<c>  => print _9; wait c; close self)

//let printNat(n : digit) : lin 1 = 
//          y <- new consumeDigit(n); 
//          wait y;
//          close self
